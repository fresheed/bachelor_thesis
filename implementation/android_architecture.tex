\subsection{Архитектура Android-приложений}

Java-код разбит на несколько подпроектов:

\begin{itemize}
\item javacommon - библиотека, реализующую бизнес-логику распознавания. Включает в себя следующие пакеты:
  \begin{itemize}
  \item events - классы, описывающие временные ряды (далее - \defn{логов}) и имеющиеся в них события, а также интерфейсы для источников этих событий
  \item transfer - интерфейсы для систем обмена сообщениями между часами и смартфоном, а также роли участников этого обмена (отправляющая/принимающая сторона)
  \item data\_channel - интерфейс для канала отправки данных в офлайн-систему
  \item utils - код для предобработки логов и их сжатия
  \end{itemize}
Выделение этого кода в отдельный подпроект позволяет абстрагироваться от особенностей Android и тестировать бизнес-логику независимо от интерфейса
\item androidcommon - общий для смартфона и часов код; зависит от javacommon. Наиболее важным модулем является диспетчер сообщений, который инкапсулирует процедуру обмена сообщениями посредством Android Message API.
\item mobile, wear - приложения для смартфона и часов соответственно; зависят от javacommon и androidcommon. Включают в себя экраны интерфейса и код для запуска обмена данными
\end{itemize}

Для управлениями зависимостями, тестами и сборкой используется Gradle.

Для более подробного описания архитектуры рассмотрим, как взаимодействуют компоненты при обмене данными.

\begin{enumerate}
\item На часах и смартфоне запускаются приложения.
  \begin{itemize}
  \item  Для часов используется базовый экран \code{WearControlScreen}, который используется исключительно для отображения полученных и отправленных сообщений
  \item На смартфоне используются два экрана, соответствующие двум режимам работы: \code{LogTransferScreen} для сбора данных и отправки в офлайн-систему и \code{LogReceiverScreen}, который управляет распознаванием движений. Оба этих экрана имеют одни и те же элементы управления - кнопки "начать сбор данных" и "прекратить сбор данных"
  \end{itemize}
\item По нажатию на кнопку "Начать сбор данных" смартфон отправляет соответствующее сообщение через диспетчер сообщений. Так как ему известен только интерфейс этого диспетчера, конкретные реализации можно свободно заменять. В ходе работы было разработано два диспетчера - использующие Wearable Data Layer API и Message API. Было установлено, что Wearable Data Layer не подходит к этой задаче, так как предполагает, что обмен данными заключается в синхронизации отдельных объектов. Обмен сообщениями плохо ложится в эту концепцию, поэтому для работы был выбран Message API.
\item На стороне часов \code{WearControlScreen} при инициализации создаёт объект WearPeer, реализующий интерфейс \code{MessageReceiver}. Этот интерфейс предназначен для объектов, которые могут получать сообщения от диспетчера и выполнять в ответ какие-либо действия. Этот интерфейс независим от механизма передачи сообщений, что значительно упрощает его тестирование и реализацию. Конкретно \code{WearPeer} отвечает за начало и окончание записи логов. В качестве аргументов конструктора он принимает диспетчер сообщений, источник логов и объект для обратного вызова (callback). Необходимость в callback обусловлена тем, что обработка сообщений происходит асинхронно основному потоку, и необходимо иметь возможность уведомлять другие компоненты системы о результатах обработки. В качестве callback передаются экраны приложений, которые отображают результаты обработки. Как и диспетчер сообщений, callback передаётся как объект соответствующего интерфейса
\item При получении сообщения "начать сбор данных" \code{WearPeer} проверяет своё текущее состояние (ожидание/запись). Если он находится в ожидании, то вызывается метод источника логов, который возвращает объект сессии логирования. Сессия используется для разделения логов, созданных в разное время. Она также представлена интерфейсом \code{LoggingSession}; конкретная реализация зависит от источника логов. Этот источник задаётся при создании \code{WearPeer}; в качестве параметра он принимает тип сенсора. Используемая реализация возвращает объект сессии, который ожидает вызова со стороны ОС для приёма новых данных сенсора. Android не позволяет получать данные с точно заданной частотой - можно только указать её приблизительно. На практике частота поступления событий составляет примерно 70 Гц
\item При получении новых данных сессия записывает в объект \code{ActionLog} новое событие (\code{ActionEvent}). Событие состоит из временной метки (представлена 8-байтным типом long) и массива значений сенсора. \code{ActionLog} - это вспомогательный объект, содержащий список событий и используемый, в частности, для контроля размерности добавляемых событий и максимальной длины лога.
\item При получении сообщения "прекратить сбор данных" \code{WearPeer} вызывает на сессии метод \code{stopAndRetrieve}, который останавливает получение данных от ОС и возвращает ActionLog с записанными событиями
\item Полученные события обрабатываются объектом \code{Events\-Log\-Compressor}. В результате обработки возвращается байтовый массив, каждые 20 байт которого обозначают отдельное событие: 8 байт на временную метку, 3 значения типа float (по 4 байта) для значений сенсоров. Google рекомендует отправлять сообщения размером не больше 100 Кбайт; для упрощения расчётов примем максимальный размер равным 100000 байт. Тогда в одном сообщении можно отправить не более 5000 событий. С учётом частоты поступления событий, в сообщении можно передать данные о событиях приблизительно за последние 70 секунд
\item Сообщение типа "лог" через диспетчер отправляется смартфону
\item На стороне смартфона также используется объект с интерфейсом \code{MessageReceiver}. В зависимости от режима, это либо \code{LogProcessingPeer} (управляет классификацией логов), либо \code{LogTransferPeer} (отправляет данные в офлайн-систему). \code{LogProcessingPeer} с помощью \code{EventsLogCompressor} преобразует байтовый массив в лог. Затем он вызывает объект интерфейса \code{LogClassifier}, чтобы произвести классификацию. \code{LogTransferPeer} же отправляет полученный байтовый массив для дальнейшей офлайн-обработки
\item \code{LogClassifier} представляет собой интерфейс к классификатору логов. Он инкапсулирует как алгоритм выделения признаков, так и непосредственно классификатор. Основной метод - \code{classify}, который принимает лог и возвращает один из объектов перечисления (enum), соответствующий той или иной активности
\end{enumerate}